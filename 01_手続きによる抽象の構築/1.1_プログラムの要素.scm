; 基本式
; 組み合わせ法
; 抽象化法

; 1.1.1 式
; 基本的な式の一つは整数である
123

; 式の並びを括弧で囲んで手続きの作用を表現 = 組み合わせ(combinations)
(+ 12 25)
(* 12 25)
(/ 10 2)

; 演算子(operator), 非演算子(operands)

; 前置記法
(+ 1 23 543 54354)

;入れ子
(+ (* 3 5) (- 10 6))

(+ (* 3
	  (+ (* 2 4)
		 (+ 3 5)))
   (+ (- 10 7)
	  6))

; 1.1.2 名前と環境

(define size 2)
(define pi 3.1415)
(define radius 10)
(* pi (* radius radius))
(define circumference (* 2 pi radius)) 
circumference
; defineはcircumferenceのような合成演算の結果を刺すにも単純な名前を使うことが出来るので
; 最も単純な抽象手段である

; 値と記号を対応付けて後から取り出すために、解釈系は記憶を保持している
; その記憶を環境(environment)という


; 1.1.3 組み合わせの評価

; 1 組み合わせの部分式を評価する(部分式:組み合わせに与えられた1つの式)
; 2 最左部分式の値である手続きを残りの部分式である引数に作用させる
; 第1の規則で再帰的に部分式を評価する

; 基本的な式
; * 数字列の値
; * 基本演算子(帯域環境で機械命令に対応付けられた名前)
; * それ以外の名前の値(環境で名前と対応づけられたオブジェクト)

; 特殊形式
(define x 3)
; difineをxと3に評価するわけではない


; 1.1.4 合成手続き

(define (square x) (* x x))
; squareという合成手続きが出来る
(square 2)
(square (square 2))

(define (sum-of-squares x y)
  (+ (square x) (square y)))
(sum-of-squares 3 4)

(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))

(f 5)
; 基本的手続き 演算子,組み込み手続き
; 合成手続き 合成された手続き

; 1.1.5 手続き作用の置き換えモデル
; 演算子が合成手続きの名前になっている組合せでも、演算子でも解釈系はほとんど同じプロセスを踏む 

(f 5) ;を式を評価する
(sum-of-squares (+ a 1) (* a 2)) ; 仮パラメータaに5を適用する
(sum-of-squares (+ 5 1) (* 5 2)) ; 作用させる演算子を評価し、被演算子を評価する
(+ (square 6) (square 10)) ; に帰着する
(+ (* 6 6) (* 10 10))
(+ 36 100)
136

; コレを手続き作用の置換えモデルという

; 作用的順序と正規順序

; 作用的順序の評価
; 前述

; 正規順序の評価
; 指揮をすべて展開し、監訳する
(f 5)
(sum-of-squares (+ 5 1) (* 5 2))
(+ (square (+ 5 1)) (square (* 5 2)))
(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2))) ; (+ 5 1)と(* 5 2)は必要になるまで評価されていない 
(+ (* 6 6) (* 10 10))
(+ 36 100)
136

; 1.1.6 条件式と述語
; 場合分けを記述する特殊形式(cond)
(define (abs x)
  (cond ((> x 0) x)
		((= x 0) 0)
		((< x 0) (- x))))
(abs -1)

; condにつづけて節(clauses)に入った式の対を並べて記述する
; 対の最初の式は述語(predicate)、値が真か偽を解釈する式
; 述語に対応する帰結式を返す
; 述語という用語は真か偽を返す手続きにも使う

; 別解
(define (abs x)
  (cond ((< x 0) (- x))
		(else x))) ; すべての節が通過された時に帰結式を評価する

; 別解2
(define (abs x)
  (if (< x 0) ; 場合分けの条件(述語)
	(- x) ; 条件が真のとき(帰部部)
	x)) ; 条件が偽(代替部)

; 合成述語を作るための論理合成演算
;(and <e1> ... <en>) 
;(or <e1> ... <en>) 
;(not <e>) 

; 例：範囲5<x<10
(and (> x 5) (< x 10))
; 例：greater than or equalを演算子っぽく定義
(define (>= x y)
  (or (> x y) (= x y)))
; 別解
(define (>= xy)
  (not (< x y)))

; 問題1.1

10 ; => 10
(+ 5 3 4) ; => 12
(- 9 1) ; => 8
(/ 6 2) ; => 3
(+ (* 2 4) (- 4 6)) ; => 6
(define a 3) ; => a
(define b (+ a 1)) ; => b
(+ a b (* a b)) ; => 19
(= a b) ; => #f
(if (and (> b a) (< b (* a b)))
  b
  a) ; => 4
(cond ((= a 4) 6)
	  ((= b 4) (+ 6 7 a))
	  (else 25)) ; => 16
(+ 2 (if (> b a) b a)) ; => 6
(* (cond ((> a b) a)
		 ((< a b) b)
		 (else -1))
   (+ a 1)) ; => 16

; 問題1.2
; 5+4+(2-(3-(6+4/5)))
; ------------------
;   3(6-2)(2-7)
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7))) ; あってる？

; 問題1.3
; 3つの数を引数としてとり、大きい2つの数の二乗の和を返す手続きを定義せよ
(define (hoge x y z) (cond ((= x (min x y z)) (sum-of-squares y z))
						   ((= y (min x y z)) (sum-of-squares x z))
						   (else (sum-of-squares x y))
						   ))
(hoge 4 2 3) ; あってるの…？

; 問題1.4
; われわれの評価モデルは演算子が合成式である組み合わせでも使えることを観察せよ。それにしたがって、次の手続きの振る舞いを述べよ
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
; aにbの絶対値を加算するという目的に対し、bが正の値であれば加算、負の値であれば減算というアプローチをとる
; 定義された組み合わせの演算子では、ifの述部でbの正負を判別し、帰結部で演算子を返すことで処理を実現している

; 問題 1.5
; Ben Bitdiddleは自分が直面するインタプリタが適用順評価と正規順評価のどちらを用いるか決定するテストを開発した。まず以下の2つの手続きを定義する
(define (p) (p))

(define (test x y)
  (if (= x 0)
	0
	y))
; 次に以下の式を評価する
(test 0 (p))
; 作用順評価
; 0とpが評価されるがpはpを定義しているため無限ループになる
; 正規順評価
(if (= 0 0)
  0
  (p))
; となり述語が真のため帰結部の0が変える。代替部(p)は評価されないまま完了する

; 1.1.7 例：ニュートン法による平方根
; 手続きはふつうの数学の巻数に似ているが、手続きは効果的である必要がある
; √x = the y such that y ≥0 and y^2 = x (ルートxにおいてyは0以上で二乗するとxに等しい)
; これは正しい数学の関数である。しかし一方でこの定義は手続きの記述ではない
(define (sqrt x)
  (the y (and (>= y 0)
			  (= (square y) x)))) ; 動作しない
; 関数と手続の対称性は,事物の属性の"説明"と"行いの説明"との間の区別の反映である
; それは宣言的知識と手続的知識の間の区別と言い換えれる
; ＊数学では宣言的(what is)記述を用いる
; * コンピュータサイエンスでは手続的(how to)記述を用いる

; ニュートン法で平方根を求める
; ある数xの平方根の推定値としてyを保つ場合、よりよい推定値を求めるために、yとx/yの平均を取るという簡単な操作を実行する
; 推定値  商(x/推定値)           平均(商+推定値/x)
; 1       (2/1) = 2              ((2+1)/2) = 1.5
; 1.5     (2/1.5) = 1.3333       (1.3333 + 1.5)/2) = 1.4167
; 1.14167 (2/1.14167) = 1.14118  (1.14167 + 1.14118)/2) = 1.4142
; 1.14142 ...

; ニュートン法を手続で表現する
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
	guess
	(sqrt-iter (improve guess x) x)))
; 推定値は前回の推定値と商の平均をとることで改善される
(define (improve guess x) ;推定値の精度を上げる手続
  (average guess (/ x guess))) 
(define (average x y)
  (/ (+ x y) 2))

; 十分に良いの定義
; その二乗と被開法数の差が0.001より小さい
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.0001))

(define (sqrt x)
  (sqrt-iter 1.0 x)) ; 推定値を1から始める
(sqrt 9)
(sqrt (+ 100 37))

; 再起だけでできるよ！そうなんだ！すごいね！

; なぜcondがあるのにifが特殊形式として提供されているのか
; 新たなifをcondで定義してみる
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
		(else else-clause)))
(new-if (= 2 3) 0 5) ; => 5
(new-if (= 1 1) 0 5) ; => 0

; new-ifでsqrt-iter書きなおす
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
	guess
	(sqrt-iter (improve guess x) x)))

; 問題1.6 平方根の計算にこれを試したとき何が起こるだろう 
(sqrt 9) ;展開していく
(sqrt-iter 1.0 9)
(new-if (good-enough? 1.0 9)
		1.0
		(sqrt-iter (improve 1.0 9) 1.0)) ; 作用順の評価は引数から評価するので(good-enough? guess x)が真でも先にsqrt-iterが評価されループに陥る

; 問題1.7
(sqrt 0.0001) ; => 1 ; 推定値が許容誤差より小さくなってしまうと早々にループが止まって精度が出ない
(sqrt 10000000000) ; => 100000 ナンデ動かないの！？ニンジャナンデ！？
